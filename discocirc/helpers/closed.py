# -*- coding: utf-8 -*-

"""
Implements the free closed monoidal category.
"""

from discopy import monoidal, messages, closed
from lambeq import BobcatParser


class Ty(monoidal.Ty):  # TODO: No reason to subclass monoidal.Ty / REWRITING
    """
    Objects in a free closed monoidal category.
    Generated by the following grammar:

        ty ::= Ty(name) | ty @ ty | ty >> ty

    Examples
    --------
    >>> x, y = Ty('x'), Ty('y')
    >>> print(x >> y >> x)
    ((x → y) → x)
    >>> print((y >> x >> y) @ x)
    ((y → x) → y) @ x
    """

    inside: tuple[monoidal.Ty]

    def __init__(self, *inside, input=None, output=None, index=None):
        """
        Initialize the Ty class. `index` is extra information added to Ty. This is used for coindexing.
        """
        self.input, self.output, self.index = input, output, index
        super().__init__()  # initialize empty monoidal.Ty class

        if len(inside) > 1:
            self.inside = tuple(x if isinstance(x, Ty) else Ty(x) for x in inside)
        elif len(inside) == 1:
            if isinstance(inside[0], Ty):
                if self.index == None:
                    self.index = inside[0].index
                self.inside = inside[0].inside
            elif isinstance(inside[0], monoidal.Ty):
                self.inside = (inside[0].inside[0], )
            else:
                self.inside = (monoidal.Ty(inside[0]), )

    def __rshift__(self, other):
        """
        Define the right shift operator to create a function
        """
        return Func(self, other)

    def __str__(self):
        """
        Return the string representation of the Ty object.
        """
        return self.to_string()

    def to_string(self, index=True):
        """
        Return the string representation of the Ty object.
        """
        if index:
            if len(self.inside) > 1:
                return f'({super().__str__()}){index_to_string(self.index)}'
            return super().__str__() + f'{index_to_string(self.index)}'
        else:
            if len(self.inside) > 1:
                return ' @ '.join(map(lambda x: x.to_string(index), self.inside))
            return super().__str__()

    def tensor(self, *others):
        """
        Return the tensor product of self and others.
        """
        for other in others:
            if not isinstance(other, monoidal.Ty):
                raise TypeError(messages.type_err(monoidal.Ty, other))
        objects = []
        for t in (self,) + others:
            if len(t.inside) > 1:
                objects += t.inside
            elif len(t.inside) == 1:
                objects.append(t)
        return Ty(*objects)

    @staticmethod
    def upgrade(old: monoidal.Ty):
        """
        Upgrade a monoidal.Ty to a Ty.
        """
        if len(old) == 1 and isinstance(old[0], Func):
            return old[0]
        return Ty(*old.inside)

    def downgrade(self):
        """
        Downgrade a Ty to a monoidal.Ty.
        """
        if isinstance(self, Func):
            return self
        inside = []
        for t in self.inside:
            if isinstance(t, monoidal.Ty) and not isinstance(t, Func):
                inside.extend(t.inside)
            else:
                inside.append(t)
        return monoidal.Ty(*inside)


class Func(Ty):
    """
    A subclass of Ty representing Function objects in a free closed monoidal category.
    """
    def __init__(self, input=None, output=None, index=None):
        """
        Initialize the Func class.
        """
        name = f'({repr(input)} → {repr(output)})'
        self.input = input
        self.output = output
        super().__init__(name, index=index)

    def __repr__(self):
        """
        Return the string representation of the Func object.
        """
        return "({} → {})".format(repr(self.input), repr(self.output))

    def __str__(self):
        """
        Return the string representation of the Func object.
        """
        return self.to_string()

    def to_string(self, index=True):
        """
        Return the string representation of the Func object.
        """
        if isinstance(self.input, Ty) and isinstance(self.output, Ty):
            fun_str = f'({self.input.to_string(index)} → {self.output.to_string(index)})'
        else:
            fun_str = f'({self.input} → {self.output})'
        if index:
            return f'{fun_str}{index_to_string(self.index)}'
        return f'{fun_str}'

    def __eq__(self, other):
        """
        Check if two Func objects are equal.
        """
        if not isinstance(other, Func):
            return False
        return self.input == other.input and self.output == other.output

    def __hash__(self):
        """
        Return the hash value of the Func object.
        """
        return hash(repr(self))


def biclosed_to_closed(x):
    """
    Converts the biclosed types to closed types.
    """
    if x.is_under:
        return Func(biclosed_to_closed(x.left), biclosed_to_closed(x.right))
    elif x.is_over:
        return Func(biclosed_to_closed(x.right), biclosed_to_closed(x.left))
    else:
        inside = []
        for y in x.inside:
            if isinstance(y, monoidal.Ty):
                inside.append(biclosed_to_closed(y))
            else:
                inside.append(y)
        return Ty(*inside)


def ccg_cat_to_closed(cat, word_str=None):
    """
    Converts a CCG category to a closed type.
    """
    if word_str:
        assert(type(word_str)==str)
    if cat.atomic:
        typ = biclosed_to_closed(BobcatParser._to_biclosed(cat))
    else:
        result_typ = ccg_cat_to_closed(cat.result, word_str)
        argument_typ = ccg_cat_to_closed(cat.argument, word_str)
        typ = argument_typ >> result_typ
    idx = word_str + '_' + str(cat.var) if word_str else str(cat.var)
    typ.index = set([idx])
    return typ

def downgrade_to_monoidal(typ):
    """
    Downgrades a given type to a monoidal type recursively.
    """
    if isinstance(typ, monoidal.Ob) and not isinstance(typ, monoidal.Ty):
        return typ
    elif isinstance(typ, Func):
        return Func(downgrade_to_monoidal(typ.input),
                    downgrade_to_monoidal(typ.output),
                    index=typ.index)
    elif len(typ) == 1 and isinstance(typ, Ty):
        return Ty.downgrade(typ)
    elif len(typ) > 1:
        objects = []
        for t in typ.inside:
            if not isinstance(t, Ty) and not isinstance(t, Func):
                objects.extend(t.inside)
            else:
                objects.extend(downgrade_to_monoidal(t).inside)
        typ = monoidal.Ty(*objects)
        return typ
    return typ

def uncurry_types(typ, uncurry_everything=False):
    """
    Uncurries a given type recursively. Example: (a → b → c) becomes (a x b → c).
    """
    if isinstance(typ, Func) and isinstance(typ.output, Func):
        if uncurry_everything:
            inp = uncurry_types(typ.input, uncurry_everything=True)
            out_inp = uncurry_types(typ.output.input, uncurry_everything=True)
            out_out = uncurry_types(typ.output.output, uncurry_everything=True)
        else:
            inp = typ.input
            out_inp = typ.output.input
            out_out = typ.output.output
        return uncurry_types((out_inp @ inp) >> out_out)
    elif uncurry_everything and len(typ) > 1:
        types = []
        for t in typ:
            types.append(uncurry_types(t, uncurry_everything=True))
        return Ty(*types, index = typ.index)
    else:
        return typ

def index_to_string(index):
    """
    Returns the string representation of the index.
    """
    if isinstance(index, set):
        return str(sorted(list(index)))
    return str(index)

def deep_copy_ty(ty):
    """
    Return a deep copy of the given Ty object.
    """
    if isinstance(ty, Func):
        new_ty = Func(input=deep_copy_ty(ty.input),
                      output=deep_copy_ty(ty.output),
                      index=set(ty.index) if ty.index is not None else None)
    else:
        new_ty = Ty(*[deep_copy_ty(obj) if isinstance(obj, Ty) else obj for obj in ty.objects], \
                    index=set(ty.index) if ty.index is not None else None)
    return new_ty

def types_match_modulo_curry(typ1, typ2):
    return uncurry_types(typ1, uncurry_everything=True) == uncurry_types(typ2, uncurry_everything=True)
